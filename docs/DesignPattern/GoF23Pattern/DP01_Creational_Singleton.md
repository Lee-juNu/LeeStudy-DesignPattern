## シングルトンパターンとは？

シングルトンパターンとは、下記の条件を満たした設計パターンです。

1. 特定クラスのインスタンスが1つだけ作成されることを保証すること
2. 生成されたインスタンスにはプログラム全体でアクセスできること

このパターンは GoF デザインパターンの1つであり、**生成パターン**に分類されています。


### シングルトンパターンを使用する理由
シングルトンパターンは、複数のインスタンスが生成されるとリソースを無駄にするクラスに対して、インスタンスを1回だけ生成し、グローバルにアクセスできるようにするために使用されます。たとえば、「接続プール、スレッドプール、デバイス設定オブジェクト」などのケースがあります。

上記のケースではインスタンスが複数存在することで効率が低下する場合があります。そのため、必要なときに1つのインスタンスのみを生成し、プログラム全体で共有して使用するために、シングルトンパターンが採用されます。

### シングルトンの利点

- 唯一のインスタンス
シングルトンパターンで設計されたクラスのインスタンスはアプリケーション全体でたった1つだけであることが保証されます。これにより、オブジェクトは一貫性を保ち、どこからでもアクセス可能になります。

- メモリ節約
インスタンスが1つしか存在しないため、メモリの節約が可能です。複数回コンストラクタが呼ばれても新たなインスタンスを生成しないため、メモリの使用と解放に関するオーバーヘッドが削減されます。

- 遅延初期化(Lazy Initialization)
インスタンスが必要になったタイミングで生成されるため、プログラム実行時の初期化のコストを抑えることが可能です。

### シングルトンの注意点

- 結合度の増加
シングルトンパターンはグローバルにアクセス可能なため、使用するクラスが多くなると結合度が高くなり、柔軟性が低下する可能性があります。結果 DIP（依存性逆転の原則）に違反するリスクもあります。

- テストの複雑化
シングルトンはたった１つのインスタンスを共有するため、状態を変えたりモックを使ったりするテストが困難になります。

- 状態管理の難しさ
シングルトンが状態を持つ場合、シングルトンはグローバルにアクセス可能なため、その状態が変更されやすくなります。結果、予期しない動作が発生するリスクがあります。

- 無分別な使用のリスク
アプリケーションのどこからでもアクセスできるため、慎重に管理しないと、シングルトンが無分別に使われ、変更が難しくなる可能性があります。


## シングルトンパターンを作ってみよう

### シングルトンクラス
シングルトンクラスになるためには下記の三つの条件を満たす必要があります。

1. コンストラクターを使用できないように private を指定する。
2. インスタンスを呼び出す Static のメソッドまたはプロパティが必要です。
3. インスタンスを参照できる Static の変数が必要です。

```cs
public class Logger
{
    // 3. インスタンスを参照できる Static の変数が必要です。
    private static Logger? instance;

    // 1. コンストラクターを使用できないように private を指定する。
    private Logger()
    {
    }

    // 1. コンストラクターを使用できないように private を指定する。
    public static Logger Instance
    {
        get
        {
            if (instance == null)
            {
                instance = new Logger();
            }
            return instance;
        }
    }
}
```

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        // Logger のインスタンスを取得
        // Instance は初めて呼ばれたため インスタンスを生成し返します。
        Logger logger1 = Logger.Instance;

        // 今回は Logger がすでに生成されているためコンストラクターなしで 参照変数を呼び出します。
        Logger logger2 = Logger.Instance;

        // 2つのインスタンスが同一か確認
        if (ReferenceEquals(logger1, logger2))
        {
            // 同じインスタンスであることを確認
            Console.WriteLine("logger1 と logger2 は同じインスタンスです。");
        }
        else
        {
            // 異なるインスタンスである場合（通常はこのケースは発生しません）
            Console.WriteLine("logger1 と logger2 は異なるインスタンスです。");
        }
    }
}
```

### 上記のコードで利点の復讐

1. 唯一のインスタンス
`Logger` クラスのインスタンスが初回呼び出し時にのみ生成され、その後は同じインスタンスが返されます。これにより、`Logger` のインスタンスが複数生成されることはなく、メモリの浪費を防ぎます。

2. 遅延初期化(Lazy Initialization)
`Logger` のインスタンスは、最初に Instance プロパティが呼び出されたときにのみ生成されます。 `Logger` 使用されない場合はインスタンスが生成されずにプログラムは終了します。また起動時のリソース消費を抑えることが可能です。

3. 一貫性のあるアクセス
シングルトンパターンを使用すると、プログラム内で Logger クラスのインスタンスに対するアクセスが常に同じオブジェクトを指すことが保証されます。これにより、一貫したログ記録や設定の参照が可能です。

### 上記のコードから補完する点

マルチスレッド環境になるのであればスレッドセーフを実行する必要があるなので`DP01_Creeational_Singleton_Multi`プロジェクトを別で生成して作成すること。